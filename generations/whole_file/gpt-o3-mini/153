#
# @lc app=leetcode id=2379 lang=python3
#
# [2379] 获取K个连续黑块的最小重新着色次数
#
# https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/
#
# 算法
# 简单 (59.47%)
# 点赞：751
# 不喜欢: 21
# 总接受：61.3K
# 总提交次数：103K
# 测试用例示例：'"WBBWWBBWBW"\n7
#
# 给定一个长度为 n 的 0 索引字符串 blocks，其中 blocks[i] 是
# “W”或“B”，表示第i个方块的颜色。字符
# W' 和 'B' 分别表示白色和黑色。
# 
# 你还会得到一个整数 k，它是所需的连续黑色块的数量
# 黑色方块。
# 
# 在一次操作中，你可以将一个白色块重新着色为黑色块
# 块。
# 
# 返回所需的最小操作次数，以确保至少有
# 至少有一个 k 个连续黑块的出现。
# 
# 
# 示例 1:
# 
# 
# 输入：blocks = "WBBWWBBWBW", k = 7
# 输出：3
# 解释：
# 一种实现7个连续黑块的方法是重新着色第0、第3个和
# 第4个块
# 使得 blocks = "BBBBBBBWBW"。
# 可以证明，没有办法在少于3次操作中实现7个连续的黑块。
# 少于3次操作。
# 因此，我们返回3。
# 
# 
# 示例 2:
# 
# 
# 输入: blocks = "WBWBBBW", k = 2
# 输出：0
# 解释：
# 已经存在2个连续的黑色块，因此不需要进行任何更改。
# 因此，我们返回 0。
# 
# 
# 
# 约束条件：
# 
# 
# n == blocks.length
# 1 <= n <= 100
# blocks[i] 不是 'W' 就是 'B'。
# 1 <= k <= n
# 
# 
#

# @lc 代码开始
class Solution:
    def minimumRecolors(self, blocks: str, k: int) -> int:
        # 统计第一个长度为 k 的窗口中的白色块数量
        recolors = blocks[:k].count('W')
        min_recolors = recolors
        
        # 滑动窗口遍历整个字符串
        for i in range(k, len(blocks)):
            # 若离开窗口的块为白色，减少计数
            if blocks[i - k] == 'W':
                recolors -= 1
            # 若进入窗口的块为白色，增加计数
            if blocks[i] == 'W':
                recolors += 1
                
            min_recolors = min(min_recolors, recolors)
            
        return min_recolors
# @lc code=end